# coding: utf-8

"""
    ABIS REST API

    Innovatrics ABIS proprietary REST API

    The version of the OpenAPI document: 6.62.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel, StrictStr, field_validator
from pydantic import Field
from typing_extensions import Annotated
from abis.rest.client.models.dna_laboratory_setting import DnaLaboratorySetting
from abis.rest.client.models.dna_profile_data import DnaProfileData
from abis.rest.client.models.dna_str import DnaStr

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class Dna(BaseModel):
    """
    Dna
    """ # noqa: E501
    dna_strs: Optional[List[DnaStr]] = Field(default=None, alias="dnaStrs")
    index: Optional[Annotated[int, Field(strict=True, ge=0)]] = None
    laboratory_setting: Optional[DnaLaboratorySetting] = Field(default=None, alias="laboratorySetting")
    number_of_analysis: Optional[StrictStr] = Field(default=None, description="DNA number of analysis", alias="numberOfAnalysis")
    profile_data: Optional[DnaProfileData] = Field(default=None, alias="profileData")
    profile_storage_date: Optional[datetime] = Field(default=None, description="A date-time format in the ISO-8601 calendar system", alias="profileStorageDate")
    relationship: Optional[StrictStr] = Field(default=None, description="Relationship")
    sample_collection_date: Optional[datetime] = Field(default=None, description="A date-time format in the ISO-8601 calendar system", alias="sampleCollectionDate")
    sample_donor: Optional[StrictStr] = Field(default=None, description="Sample donor", alias="sampleDonor")
    sample_type: Optional[StrictStr] = Field(default=None, description="Sample type", alias="sampleType")
    sample_typing_information: Optional[List[StrictStr]] = Field(default=None, alias="sampleTypingInformation")
    __properties: ClassVar[List[str]] = ["dnaStrs", "index", "laboratorySetting", "numberOfAnalysis", "profileData", "profileStorageDate", "relationship", "sampleCollectionDate", "sampleDonor", "sampleType", "sampleTypingInformation"]

    @field_validator('number_of_analysis')
    def number_of_analysis_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('Multiple', 'Single'):
            raise ValueError("must be one of enum values ('Multiple', 'Single')")
        return value

    @field_validator('relationship')
    def relationship_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('BiologicalChild', 'BiologicalFather', 'BiologicalMother', 'BiologicalSibling', 'MaternalRelative', 'PaternalRelative', 'OtherUnknown'):
            raise ValueError("must be one of enum values ('BiologicalChild', 'BiologicalFather', 'BiologicalMother', 'BiologicalSibling', 'MaternalRelative', 'PaternalRelative', 'OtherUnknown')")
        return value

    @field_validator('sample_donor')
    def sample_donor_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('SubjectItself', 'ClaimedRelative', 'UnknownSource'):
            raise ValueError("must be one of enum values ('SubjectItself', 'ClaimedRelative', 'UnknownSource')")
        return value

    @field_validator('sample_type')
    def sample_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('Blood', 'Bone', 'CoMingledBiologicalMaterial', 'Hair', 'Saliva', 'Semen', 'Skin', 'SweatOrFingerprint', 'Tissue', 'Tooth', 'Other', 'Unknown'):
            raise ValueError("must be one of enum values ('Blood', 'Bone', 'CoMingledBiologicalMaterial', 'Hair', 'Saliva', 'Semen', 'Skin', 'SweatOrFingerprint', 'Tissue', 'Tooth', 'Other', 'Unknown')")
        return value

    @field_validator('sample_typing_information')
    def sample_typing_information_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in ('Nuclear', 'MtDna', 'ElectropherogramData', 'ElectropherogramLadder', 'UserDefinedProfileData'):
                raise ValueError("each list item must be one of ('Nuclear', 'MtDna', 'ElectropherogramData', 'ElectropherogramLadder', 'UserDefinedProfileData')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of Dna from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of laboratory_setting
        if self.laboratory_setting:
            _dict['laboratorySetting'] = self.laboratory_setting.to_dict()
        # override the default output from pydantic by calling `to_dict()` of profile_data
        if self.profile_data:
            _dict['profileData'] = self.profile_data.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of Dna from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "index": obj.get("index"),
            "laboratorySetting": DnaLaboratorySetting.from_dict(obj.get("laboratorySetting")) if obj.get("laboratorySetting") is not None else None,
            "numberOfAnalysis": obj.get("numberOfAnalysis"),
            "profileData": DnaProfileData.from_dict(obj.get("profileData")) if obj.get("profileData") is not None else None,
            "profileStorageDate": obj.get("profileStorageDate"),
            "relationship": obj.get("relationship"),
            "sampleCollectionDate": obj.get("sampleCollectionDate"),
            "sampleDonor": obj.get("sampleDonor"),
            "sampleType": obj.get("sampleType"),
            "sampleTypingInformation": obj.get("sampleTypingInformation")
        })
        return _obj


