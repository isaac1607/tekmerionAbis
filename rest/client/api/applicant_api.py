# coding: utf-8

"""
    ABIS REST API

    Innovatrics ABIS proprietary REST API

    The version of the OpenAPI document: 6.62.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictBool, StrictInt, StrictStr

from typing import List, Optional, Union

from abis.rest.client.models.applicant_identifier_response import ApplicantIdentifierResponse
from abis.rest.client.models.applicant_response import ApplicantResponse
from abis.rest.client.models.delete_applicant_response import DeleteApplicantResponse
from abis.rest.client.models.dna_identification_candidate import DnaIdentificationCandidate
from abis.rest.client.models.dna_verification_candidate import DnaVerificationCandidate
from abis.rest.client.models.end_of_life_request import EndOfLifeRequest
from abis.rest.client.models.enroll_applicant_request import EnrollApplicantRequest
from abis.rest.client.models.export_applicant_request import ExportApplicantRequest
from abis.rest.client.models.export_applicant_response import ExportApplicantResponse
from abis.rest.client.models.exported_file import ExportedFile
from abis.rest.client.models.face_qualities_get_response import FaceQualitiesGetResponse
from abis.rest.client.models.fingerprint_qualities_get_response import FingerprintQualitiesGetResponse
from abis.rest.client.models.full_applicant_attachments import FullApplicantAttachments
from abis.rest.client.models.full_applicant_body_characteristics import FullApplicantBodyCharacteristics
from abis.rest.client.models.full_applicant_dna_modality import FullApplicantDnaModality
from abis.rest.client.models.full_applicant_documents import FullApplicantDocuments
from abis.rest.client.models.full_applicant_face_characteristics import FullApplicantFaceCharacteristics
from abis.rest.client.models.full_applicant_face_modality import FullApplicantFaceModality
from abis.rest.client.models.full_applicant_fingerprint_modality import FullApplicantFingerprintModality
from abis.rest.client.models.full_applicant_iris_modality import FullApplicantIrisModality
from abis.rest.client.models.full_applicant_request import FullApplicantRequest
from abis.rest.client.models.full_applicant_signature_modality import FullApplicantSignatureModality
from abis.rest.client.models.full_applicant_smt_characteristics import FullApplicantSmtCharacteristics
from abis.rest.client.models.hitlist import Hitlist
from abis.rest.client.models.identification_candidate import IdentificationCandidate
from abis.rest.client.models.identify_applicant_request import IdentifyApplicantRequest
from abis.rest.client.models.identify_probe_dna_request import IdentifyProbeDnaRequest
from abis.rest.client.models.import_applicant_request import ImportApplicantRequest
from abis.rest.client.models.iris_qualities_get_response import IrisQualitiesGetResponse
from abis.rest.client.models.latent_identification_candidate import LatentIdentificationCandidate
from abis.rest.client.models.latent_identify_applicant_request import LatentIdentifyApplicantRequest
from abis.rest.client.models.latent_verification_candidate import LatentVerificationCandidate
from abis.rest.client.models.latent_verify_applicant_images_request import LatentVerifyApplicantImagesRequest
from abis.rest.client.models.latent_verify_applicant_references_request import LatentVerifyApplicantReferencesRequest
from abis.rest.client.models.signature_qualities_get_response import SignatureQualitiesGetResponse
from abis.rest.client.models.update_fields_request import UpdateFieldsRequest
from abis.rest.client.models.verification_candidate import VerificationCandidate
from abis.rest.client.models.verify_applicant_images_request import VerifyApplicantImagesRequest
from abis.rest.client.models.verify_applicant_references_request import VerifyApplicantReferencesRequest
from abis.rest.client.models.verify_applicant_templates_request import VerifyApplicantTemplatesRequest
from abis.rest.client.models.verify_dna_applicant_references_request import VerifyDnaApplicantReferencesRequest

from abis.rest.client.api_client import ApiClient
from abis.rest.client.api_response import ApiResponse
from abis.rest.client.rest import RESTResponseType


class ApplicantApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def anonymize(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DeleteApplicantResponse]:
        """Soft-deletes applicant (identified by External ID) and changes its status to Deleted

        Soft-deletes applicant (identified by External ID) and changes its status to Deleted.  The operation will delete Applicant’s biometry and GDPR data: - all records from table faces which belong to provided applicant will be deleted - all applicant's liveness photos will be nullified - all applicant's documents will be nullified - all data from document_pages and its child items (document_image_fields; document_text_fields; document_page_rectangles) will be deleted - applicant custom fields will be nullified and fullName will be set to 'Anonymized'  Deleted applicant still exists in ABIS database but not in Matching cluster. Deleted applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anonymize_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anonymize_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DeleteApplicantResponse]]:
        """Soft-deletes applicant (identified by External ID) and changes its status to Deleted

        Soft-deletes applicant (identified by External ID) and changes its status to Deleted.  The operation will delete Applicant’s biometry and GDPR data: - all records from table faces which belong to provided applicant will be deleted - all applicant's liveness photos will be nullified - all applicant's documents will be nullified - all data from document_pages and its child items (document_image_fields; document_text_fields; document_page_rectangles) will be deleted - applicant custom fields will be nullified and fullName will be set to 'Anonymized'  Deleted applicant still exists in ABIS database but not in Matching cluster. Deleted applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anonymize_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anonymize_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Soft-deletes applicant (identified by External ID) and changes its status to Deleted

        Soft-deletes applicant (identified by External ID) and changes its status to Deleted.  The operation will delete Applicant’s biometry and GDPR data: - all records from table faces which belong to provided applicant will be deleted - all applicant's liveness photos will be nullified - all applicant's documents will be nullified - all data from document_pages and its child items (document_image_fields; document_text_fields; document_page_rectangles) will be deleted - applicant custom fields will be nullified and fullName will be set to 'Anonymized'  Deleted applicant still exists in ABIS database but not in Matching cluster. Deleted applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anonymize_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anonymize_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/anonymize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def call_import(
        self,
        import_applicant_request: ImportApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicantResponse]:
        """Import applicants from files. The new applicants will have status 'enrolled'.

        Create new applicants from file identified by url. The supported formats are 'abis' and 'ebts'.

        :param import_applicant_request: (required)
        :type import_applicant_request: ImportApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._call_import_serialize(
            import_applicant_request=import_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def call_import_with_http_info(
        self,
        import_applicant_request: ImportApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApplicantResponse]]:
        """Import applicants from files. The new applicants will have status 'enrolled'.

        Create new applicants from file identified by url. The supported formats are 'abis' and 'ebts'.

        :param import_applicant_request: (required)
        :type import_applicant_request: ImportApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._call_import_serialize(
            import_applicant_request=import_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def call_import_without_preload_content(
        self,
        import_applicant_request: ImportApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Import applicants from files. The new applicants will have status 'enrolled'.

        Create new applicants from file identified by url. The supported formats are 'abis' and 'ebts'.

        :param import_applicant_request: (required)
        :type import_applicant_request: ImportApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._call_import_serialize(
            import_applicant_request=import_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _call_import_serialize(
        self,
        import_applicant_request,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if import_applicant_request is not None:
            _body_params = import_applicant_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/import',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def capture(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantResponse:
        """Create a new applicant with status 'ready'.

        Create a new applicant identified using External ID and applicant data. The newapplicant will have status 'ready'. Ready applicants are not present in Matching cluster and can't be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._capture_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            dry_run=dry_run,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def capture_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantResponse]:
        """Create a new applicant with status 'ready'.

        Create a new applicant identified using External ID and applicant data. The newapplicant will have status 'ready'. Ready applicants are not present in Matching cluster and can't be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._capture_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            dry_run=dry_run,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def capture_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new applicant with status 'ready'.

        Create a new applicant identified using External ID and applicant data. The newapplicant will have status 'ready'. Ready applicants are not present in Matching cluster and can't be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._capture_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            dry_run=dry_run,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _capture_serialize(
        self,
        external_id,
        full_applicant_request,
        dry_run,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if dry_run is not None:
            
            _query_params.append(('dryRun', dry_run))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if full_applicant_request is not None:
            _body_params = full_applicant_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/abis/v6/applicants/{externalId}/capture',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def deduplicate(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantResponse:
        """Deduplicate applicant.

        Trigger deduplication for 'enrolled' applicant identified by its external id.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deduplicate_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def deduplicate_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantResponse]:
        """Deduplicate applicant.

        Trigger deduplication for 'enrolled' applicant identified by its external id.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deduplicate_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def deduplicate_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Deduplicate applicant.

        Trigger deduplication for 'enrolled' applicant identified by its external id.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deduplicate_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _deduplicate_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/deduplicate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DeleteApplicantResponse]:
        """Soft-deletes applicant (identified by External ID) and changes its status to Deleted

        Soft-deletes applicant (identified by External ID) and changes its status to Deleted. Deleted applicant still exists in ABIS database but not in Matching cluster. Deleted applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DeleteApplicantResponse]]:
        """Soft-deletes applicant (identified by External ID) and changes its status to Deleted

        Soft-deletes applicant (identified by External ID) and changes its status to Deleted. Deleted applicant still exists in ABIS database but not in Matching cluster. Deleted applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Soft-deletes applicant (identified by External ID) and changes its status to Deleted

        Soft-deletes applicant (identified by External ID) and changes its status to Deleted. Deleted applicant still exists in ABIS database but not in Matching cluster. Deleted applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def draft(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantResponse:
        """Create a new applicant with status 'draft'.

        Create a new applicant identified using External ID and applicant data. New applicant will have status 'draft'. Draft applicants do not have their templates extracted, are not present in Matching cluster and can't be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._draft_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            dry_run=dry_run,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def draft_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantResponse]:
        """Create a new applicant with status 'draft'.

        Create a new applicant identified using External ID and applicant data. New applicant will have status 'draft'. Draft applicants do not have their templates extracted, are not present in Matching cluster and can't be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._draft_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            dry_run=dry_run,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def draft_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new applicant with status 'draft'.

        Create a new applicant identified using External ID and applicant data. New applicant will have status 'draft'. Draft applicants do not have their templates extracted, are not present in Matching cluster and can't be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._draft_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            dry_run=dry_run,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _draft_serialize(
        self,
        external_id,
        full_applicant_request,
        dry_run,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if dry_run is not None:
            
            _query_params.append(('dryRun', dry_run))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if full_applicant_request is not None:
            _body_params = full_applicant_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/abis/v6/applicants/{externalId}/draft',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def end_of_life(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID")],
        end_of_life_request: EndOfLifeRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantIdentifierResponse:
        """Change applicant's status to 'end_of_life'

        Change applicant's status to 'end_of_life' and biometric individual's state to 'deceased'. This action is only allowed if applicant is primary and has status 'master' or 'denied'.

        :param external_id: External ID (required)
        :type external_id: str
        :param end_of_life_request: (required)
        :type end_of_life_request: EndOfLifeRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._end_of_life_serialize(
            external_id=external_id,
            end_of_life_request=end_of_life_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def end_of_life_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID")],
        end_of_life_request: EndOfLifeRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantIdentifierResponse]:
        """Change applicant's status to 'end_of_life'

        Change applicant's status to 'end_of_life' and biometric individual's state to 'deceased'. This action is only allowed if applicant is primary and has status 'master' or 'denied'.

        :param external_id: External ID (required)
        :type external_id: str
        :param end_of_life_request: (required)
        :type end_of_life_request: EndOfLifeRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._end_of_life_serialize(
            external_id=external_id,
            end_of_life_request=end_of_life_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def end_of_life_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID")],
        end_of_life_request: EndOfLifeRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change applicant's status to 'end_of_life'

        Change applicant's status to 'end_of_life' and biometric individual's state to 'deceased'. This action is only allowed if applicant is primary and has status 'master' or 'denied'.

        :param external_id: External ID (required)
        :type external_id: str
        :param end_of_life_request: (required)
        :type end_of_life_request: EndOfLifeRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._end_of_life_serialize(
            external_id=external_id,
            end_of_life_request=end_of_life_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _end_of_life_serialize(
        self,
        external_id,
        end_of_life_request,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if end_of_life_request is not None:
            _body_params = end_of_life_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/abis/v6/applicants/{externalId}/end-of-life',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def enroll(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        enroll_applicant_request: Optional[EnrollApplicantRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantResponse:
        """Create a new applicant with status 'enrolled'.

        This endpoint handles 2 use cases. 1. Request with applicant data in request body. Create a new applicant identified using External ID and applicant data. The new applicant will have status 'enrolled'. Enrolled applicants are present in Matching cluster and can be found by identify operation. 2. Request without applicant data in request body (request body may contain Enroll action information). Enroll already captured applicant. The enrolled applicant will be present in Matching cluster and can be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param enroll_applicant_request:
        :type enroll_applicant_request: EnrollApplicantRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._enroll_serialize(
            external_id=external_id,
            dry_run=dry_run,
            x_request_id=x_request_id,
            enroll_applicant_request=enroll_applicant_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def enroll_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        enroll_applicant_request: Optional[EnrollApplicantRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantResponse]:
        """Create a new applicant with status 'enrolled'.

        This endpoint handles 2 use cases. 1. Request with applicant data in request body. Create a new applicant identified using External ID and applicant data. The new applicant will have status 'enrolled'. Enrolled applicants are present in Matching cluster and can be found by identify operation. 2. Request without applicant data in request body (request body may contain Enroll action information). Enroll already captured applicant. The enrolled applicant will be present in Matching cluster and can be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param enroll_applicant_request:
        :type enroll_applicant_request: EnrollApplicantRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._enroll_serialize(
            external_id=external_id,
            dry_run=dry_run,
            x_request_id=x_request_id,
            enroll_applicant_request=enroll_applicant_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def enroll_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        dry_run: Annotated[Optional[StrictBool], Field(description="If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        enroll_applicant_request: Optional[EnrollApplicantRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new applicant with status 'enrolled'.

        This endpoint handles 2 use cases. 1. Request with applicant data in request body. Create a new applicant identified using External ID and applicant data. The new applicant will have status 'enrolled'. Enrolled applicants are present in Matching cluster and can be found by identify operation. 2. Request without applicant data in request body (request body may contain Enroll action information). Enroll already captured applicant. The enrolled applicant will be present in Matching cluster and can be found by identify operation.

        :param external_id: External ID. (required)
        :type external_id: str
        :param dry_run: If set 'false', object will be stored into the database at the end of this operation. Otherwise this call will just return entity without storing it into the database
        :type dry_run: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param enroll_applicant_request:
        :type enroll_applicant_request: EnrollApplicantRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._enroll_serialize(
            external_id=external_id,
            dry_run=dry_run,
            x_request_id=x_request_id,
            enroll_applicant_request=enroll_applicant_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _enroll_serialize(
        self,
        external_id,
        dry_run,
        x_request_id,
        enroll_applicant_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if dry_run is not None:
            
            _query_params.append(('dryRun', dry_run))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if enroll_applicant_request is not None:
            _body_params = enroll_applicant_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/abis/v6/applicants/{externalId}/enroll',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def export(
        self,
        export_applicant_request: ExportApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExportApplicantResponse:
        """Export applicant data into specific format.

        Export applicant data into specific format.

        :param export_applicant_request: (required)
        :type export_applicant_request: ExportApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_serialize(
            export_applicant_request=export_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_with_http_info(
        self,
        export_applicant_request: ExportApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExportApplicantResponse]:
        """Export applicant data into specific format.

        Export applicant data into specific format.

        :param export_applicant_request: (required)
        :type export_applicant_request: ExportApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_serialize(
            export_applicant_request=export_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def export_without_preload_content(
        self,
        export_applicant_request: ExportApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export applicant data into specific format.

        Export applicant data into specific format.

        :param export_applicant_request: (required)
        :type export_applicant_request: ExportApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_serialize(
            export_applicant_request=export_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _export_serialize(
        self,
        export_applicant_request,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if export_applicant_request is not None:
            _body_params = export_applicant_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        x_request_reason: Annotated[Optional[StrictStr], Field(description="Supporting information why the request was called")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantResponse:
        """Get Applicant by External ID

        Get Applicant by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param x_request_reason: Supporting information why the request was called
        :type x_request_reason: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_serialize(
            external_id=external_id,
            full_response=full_response,
            x_request_id=x_request_id,
            x_request_reason=x_request_reason,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        x_request_reason: Annotated[Optional[StrictStr], Field(description="Supporting information why the request was called")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantResponse]:
        """Get Applicant by External ID

        Get Applicant by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param x_request_reason: Supporting information why the request was called
        :type x_request_reason: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_serialize(
            external_id=external_id,
            full_response=full_response,
            x_request_id=x_request_id,
            x_request_reason=x_request_reason,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        x_request_reason: Annotated[Optional[StrictStr], Field(description="Supporting information why the request was called")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Applicant by External ID

        Get Applicant by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param x_request_reason: Supporting information why the request was called
        :type x_request_reason: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_serialize(
            external_id=external_id,
            full_response=full_response,
            x_request_id=x_request_id,
            x_request_reason=x_request_reason,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_serialize(
        self,
        external_id,
        full_response,
        x_request_id,
        x_request_reason,
        with_qualities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        if with_qualities is not None:
            
            _query_params.append(('withQualities', with_qualities))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        if x_request_reason is not None:
            _header_params['X-Request-Reason'] = x_request_reason
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_applicants_hitlists(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Hitlist]:
        """Get Applicant Hitlists by External ID

        Get Applicant Hitlists by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_applicants_hitlists_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Hitlist]",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_applicants_hitlists_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Hitlist]]:
        """Get Applicant Hitlists by External ID

        Get Applicant Hitlists by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_applicants_hitlists_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Hitlist]",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_applicants_hitlists_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Applicant Hitlists by External ID

        Get Applicant Hitlists by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_applicants_hitlists_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Hitlist]",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_applicants_hitlists_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/hitlists',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_attachments(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantAttachments:
        """Get applicant attachments by External ID

        Get applicant attachments by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_attachments_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantAttachments",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_attachments_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantAttachments]:
        """Get applicant attachments by External ID

        Get applicant attachments by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_attachments_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantAttachments",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_attachments_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant attachments by External ID

        Get applicant attachments by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_attachments_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantAttachments",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_attachments_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/attachments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_body_characteristics(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantBodyCharacteristics:
        """Get applicant body characteristics by External ID

        Get applicant body characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_body_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantBodyCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_body_characteristics_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantBodyCharacteristics]:
        """Get applicant body characteristics by External ID

        Get applicant body characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_body_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantBodyCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_body_characteristics_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant body characteristics by External ID

        Get applicant body characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_body_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantBodyCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_body_characteristics_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/body-characteristics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_dna(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        dna_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantDnaModality:
        """Get applicant DNA by External ID and dna index

        Get applicant DNA by External ID and dna index

        :param external_id: External ID. (required)
        :type external_id: str
        :param dna_index: Object index, starts from 1 (required)
        :type dna_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dna_serialize(
            external_id=external_id,
            dna_index=dna_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDnaModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_dna_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        dna_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantDnaModality]:
        """Get applicant DNA by External ID and dna index

        Get applicant DNA by External ID and dna index

        :param external_id: External ID. (required)
        :type external_id: str
        :param dna_index: Object index, starts from 1 (required)
        :type dna_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dna_serialize(
            external_id=external_id,
            dna_index=dna_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDnaModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_dna_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        dna_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant DNA by External ID and dna index

        Get applicant DNA by External ID and dna index

        :param external_id: External ID. (required)
        :type external_id: str
        :param dna_index: Object index, starts from 1 (required)
        :type dna_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dna_serialize(
            external_id=external_id,
            dna_index=dna_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDnaModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_dna_serialize(
        self,
        external_id,
        dna_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if dna_index is not None:
            _path_params['dnaIndex'] = dna_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/dna/{dnaIndex}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_dnas(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantDnaModality:
        """Get applicant DNAs by External ID

        Get applicant DNAs by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dnas_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDnaModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_dnas_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantDnaModality]:
        """Get applicant DNAs by External ID

        Get applicant DNAs by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dnas_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDnaModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_dnas_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant DNAs by External ID

        Get applicant DNAs by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dnas_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDnaModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_dnas_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/dnas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_documents(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantDocuments:
        """Get applicant documents by External ID

        Get applicant documents by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_documents_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDocuments",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_documents_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantDocuments]:
        """Get applicant documents by External ID

        Get applicant documents by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_documents_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDocuments",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_documents_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant documents by External ID

        Get applicant documents by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_documents_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantDocuments",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_documents_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/documents',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_face(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantFaceModality:
        """Get applicant face by External ID and face index

        Get applicant face by External ID and face index

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_face_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantFaceModality]:
        """Get applicant face by External ID and face index

        Get applicant face by External ID and face index

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_face_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant face by External ID and face index

        Get applicant face by External ID and face index

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_face_serialize(
        self,
        external_id,
        face_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if face_index is not None:
            _path_params['faceIndex'] = face_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/faces/{faceIndex}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_face_characteristics(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantFaceCharacteristics:
        """Get applicant face characteristics by External ID

        Get applicant face characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_face_characteristics_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantFaceCharacteristics]:
        """Get applicant face characteristics by External ID

        Get applicant face characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_face_characteristics_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant face characteristics by External ID

        Get applicant face characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_face_characteristics_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/face-characteristics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_face_image(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get face image of applicant (identified by External ID). The face is identified by face index.

        Get face image of applicant (identified by External ID). The face is identified by face index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_image_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_face_image_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get face image of applicant (identified by External ID). The face is identified by face index.

        Get face image of applicant (identified by External ID). The face is identified by face index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_image_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_face_image_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get face image of applicant (identified by External ID). The face is identified by face index.

        Get face image of applicant (identified by External ID). The face is identified by face index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_image_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_face_image_serialize(
        self,
        external_id,
        face_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if face_index is not None:
            _path_params['faceIndex'] = face_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/faces/{faceIndex}/image',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_face_qualities(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FaceQualitiesGetResponse:
        """Get applicant face qualities by External ID and face index

        Get applicant face qualities by External ID and face index

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_qualities_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FaceQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_face_qualities_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FaceQualitiesGetResponse]:
        """Get applicant face qualities by External ID and face index

        Get applicant face qualities by External ID and face index

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_qualities_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FaceQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_face_qualities_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant face qualities by External ID and face index

        Get applicant face qualities by External ID and face index

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_qualities_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FaceQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_face_qualities_serialize(
        self,
        external_id,
        face_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if face_index is not None:
            _path_params['faceIndex'] = face_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/faces/{faceIndex}/qualities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_face_template(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get face template of applicant (identified by External ID) in ICS format. The face is identified by face index.

        Get face template of applicant (identified by External ID) in ICS format. The face is identified by face index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_template_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_face_template_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get face template of applicant (identified by External ID) in ICS format. The face is identified by face index.

        Get face template of applicant (identified by External ID) in ICS format. The face is identified by face index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_template_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_face_template_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        face_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get face template of applicant (identified by External ID) in ICS format. The face is identified by face index.

        Get face template of applicant (identified by External ID) in ICS format. The face is identified by face index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param face_index: Object index, starts from 1 (required)
        :type face_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_face_template_serialize(
            external_id=external_id,
            face_index=face_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_face_template_serialize(
        self,
        external_id,
        face_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if face_index is not None:
            _path_params['faceIndex'] = face_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/faces/{faceIndex}/template',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_faces(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantFaceModality:
        """Get applicant faces by External ID

        Get applicant faces by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_faces_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_faces_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantFaceModality]:
        """Get applicant faces by External ID

        Get applicant faces by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_faces_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_faces_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant faces by External ID

        Get applicant faces by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_faces_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFaceModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_faces_serialize(
        self,
        external_id,
        x_request_id,
        with_qualities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if with_qualities is not None:
            
            _query_params.append(('withQualities', with_qualities))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/faces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_file(
        self,
        file_id: Annotated[StrictStr, Field(description="File Id of the exported file.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExportedFile:
        """Get info about the exported file.

        Get info about the exported file.

        :param file_id: File Id of the exported file. (required)
        :type file_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_serialize(
            file_id=file_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportedFile",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_file_with_http_info(
        self,
        file_id: Annotated[StrictStr, Field(description="File Id of the exported file.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExportedFile]:
        """Get info about the exported file.

        Get info about the exported file.

        :param file_id: File Id of the exported file. (required)
        :type file_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_serialize(
            file_id=file_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportedFile",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_file_without_preload_content(
        self,
        file_id: Annotated[StrictStr, Field(description="File Id of the exported file.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get info about the exported file.

        Get info about the exported file.

        :param file_id: File Id of the exported file. (required)
        :type file_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_file_serialize(
            file_id=file_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportedFile",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_file_serialize(
        self,
        file_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if file_id is not None:
            _path_params['fileId'] = file_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/export/{fileId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantFingerprintModality:
        """Get applicant fingerprint by External ID and fingerprint index

        Get applicant fingerprint by External ID and fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFingerprintModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantFingerprintModality]:
        """Get applicant fingerprint by External ID and fingerprint index

        Get applicant fingerprint by External ID and fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFingerprintModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant fingerprint by External ID and fingerprint index

        Get applicant fingerprint by External ID and fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFingerprintModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_serialize(
        self,
        external_id,
        fingerprint_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if fingerprint_index is not None:
            _path_params['fingerprintIndex'] = fingerprint_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_embedding_template(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get single fingerprint embedding template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint embedding template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_embedding_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_embedding_template_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get single fingerprint embedding template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint embedding template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_embedding_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_embedding_template_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get single fingerprint embedding template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint embedding template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_embedding_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_embedding_template_serialize(
        self,
        external_id,
        fingerprint_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if fingerprint_index is not None:
            _path_params['fingerprintIndex'] = fingerprint_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/embedding-template',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_ics_template(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_ics_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_ics_template_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_ics_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_ics_template_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_ics_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_ics_template_serialize(
        self,
        external_id,
        fingerprint_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if fingerprint_index is not None:
            _path_params['fingerprintIndex'] = fingerprint_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/ics-template',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_image(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get fingerprint image of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get fingerprint image of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_image_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_image_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get fingerprint image of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get fingerprint image of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_image_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_image_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get fingerprint image of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get fingerprint image of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_image_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_image_serialize(
        self,
        external_id,
        fingerprint_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if fingerprint_index is not None:
            _path_params['fingerprintIndex'] = fingerprint_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/image',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_latent_template(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get single fingerprint latent template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint latent template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_latent_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_latent_template_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get single fingerprint latent template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint latent template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_latent_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_latent_template_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get single fingerprint latent template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint latent template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_latent_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_latent_template_serialize(
        self,
        external_id,
        fingerprint_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if fingerprint_index is not None:
            _path_params['fingerprintIndex'] = fingerprint_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/latent-template',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_qualities(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FingerprintQualitiesGetResponse:
        """Get applicant fingerprint qualities by External ID and fingerprint index

        Get applicant fingerprint qualities by External ID and fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_qualities_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FingerprintQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_qualities_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FingerprintQualitiesGetResponse]:
        """Get applicant fingerprint qualities by External ID and fingerprint index

        Get applicant fingerprint qualities by External ID and fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_qualities_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FingerprintQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_qualities_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant fingerprint qualities by External ID and fingerprint index

        Get applicant fingerprint qualities by External ID and fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprint_qualities_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FingerprintQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_qualities_serialize(
        self,
        external_id,
        fingerprint_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if fingerprint_index is not None:
            _path_params['fingerprintIndex'] = fingerprint_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/qualities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprint_template(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """(Deprecated) Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/template is deprecated.", DeprecationWarning)

        _param = self._get_fingerprint_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprint_template_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """(Deprecated) Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/template is deprecated.", DeprecationWarning)

        _param = self._get_fingerprint_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprint_template_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        fingerprint_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        Get single fingerprint template of applicant (identified by External ID). The fingerprint is identified by fingerprint index

        :param external_id: External ID. (required)
        :type external_id: str
        :param fingerprint_index: Object index, starts from 1 (required)
        :type fingerprint_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/template is deprecated.", DeprecationWarning)

        _param = self._get_fingerprint_template_serialize(
            external_id=external_id,
            fingerprint_index=fingerprint_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprint_template_serialize(
        self,
        external_id,
        fingerprint_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if fingerprint_index is not None:
            _path_params['fingerprintIndex'] = fingerprint_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/fingerprints/{fingerprintIndex}/template',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_fingerprints(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantFingerprintModality:
        """Get applicant fingerprints by External ID

        Get applicant fingerprints by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprints_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFingerprintModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_fingerprints_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantFingerprintModality]:
        """Get applicant fingerprints by External ID

        Get applicant fingerprints by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprints_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFingerprintModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_fingerprints_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant fingerprints by External ID

        Get applicant fingerprints by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_fingerprints_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantFingerprintModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_fingerprints_serialize(
        self,
        external_id,
        x_request_id,
        with_qualities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if with_qualities is not None:
            
            _query_params.append(('withQualities', with_qualities))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/fingerprints',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_iris(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantIrisModality:
        """Get applicant iris by External ID and iris index

        Get applicant iris by External ID and iris index

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantIrisModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_iris_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantIrisModality]:
        """Get applicant iris by External ID and iris index

        Get applicant iris by External ID and iris index

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantIrisModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_iris_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant iris by External ID and iris index

        Get applicant iris by External ID and iris index

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantIrisModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_iris_serialize(
        self,
        external_id,
        iris_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if iris_index is not None:
            _path_params['irisIndex'] = iris_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/irises/{irisIndex}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_iris_image(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get iris image of applicant (identified by External ID). The iris is identified by iris index.

        Get iris image of applicant (identified by External ID). The iris is identified by iris index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_image_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_iris_image_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get iris image of applicant (identified by External ID). The iris is identified by iris index.

        Get iris image of applicant (identified by External ID). The iris is identified by iris index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_image_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_iris_image_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get iris image of applicant (identified by External ID). The iris is identified by iris index.

        Get iris image of applicant (identified by External ID). The iris is identified by iris index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_image_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_iris_image_serialize(
        self,
        external_id,
        iris_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if iris_index is not None:
            _path_params['irisIndex'] = iris_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/irises/{irisIndex}/image',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_iris_qualities(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> IrisQualitiesGetResponse:
        """Get applicant iris qualities by External ID and iris index

        Get applicant iris qualities by External ID and iris index

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_qualities_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IrisQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_iris_qualities_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[IrisQualitiesGetResponse]:
        """Get applicant iris qualities by External ID and iris index

        Get applicant iris qualities by External ID and iris index

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_qualities_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IrisQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_iris_qualities_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant iris qualities by External ID and iris index

        Get applicant iris qualities by External ID and iris index

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_qualities_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "IrisQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_iris_qualities_serialize(
        self,
        external_id,
        iris_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if iris_index is not None:
            _path_params['irisIndex'] = iris_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/irises/{irisIndex}/qualities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_iris_template(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get iris template of applicant (identified by External ID) in ICS format. The iris is identified by iris index.

        Get iris template of applicant (identified by External ID) in ICS format. The iris is identified by iris index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_template_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_iris_template_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get iris template of applicant (identified by External ID) in ICS format. The iris is identified by iris index.

        Get iris template of applicant (identified by External ID) in ICS format. The iris is identified by iris index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_template_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_iris_template_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        iris_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get iris template of applicant (identified by External ID) in ICS format. The iris is identified by iris index.

        Get iris template of applicant (identified by External ID) in ICS format. The iris is identified by iris index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param iris_index: Object index, starts from 1 (required)
        :type iris_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_iris_template_serialize(
            external_id=external_id,
            iris_index=iris_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_iris_template_serialize(
        self,
        external_id,
        iris_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if iris_index is not None:
            _path_params['irisIndex'] = iris_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/irises/{irisIndex}/template',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_irises(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantIrisModality:
        """Get applicant irises by External ID

        Get applicant irises by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_irises_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantIrisModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_irises_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantIrisModality]:
        """Get applicant irises by External ID

        Get applicant irises by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_irises_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantIrisModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_irises_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant irises by External ID

        Get applicant irises by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_irises_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantIrisModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_irises_serialize(
        self,
        external_id,
        x_request_id,
        with_qualities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if with_qualities is not None:
            
            _query_params.append(('withQualities', with_qualities))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/irises',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_list(
        self,
        external_id: Annotated[StrictStr, Field(description="Comma-separated list of External ID")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        x_request_reason: Annotated[Optional[StrictStr], Field(description="Supporting information why the request was called")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        with_siblings: Annotated[Optional[StrictBool], Field(description="Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicantResponse]:
        """Get applicants by External ID

        Get applicants by External ID

        :param external_id: Comma-separated list of External ID (required)
        :type external_id: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param x_request_reason: Supporting information why the request was called
        :type x_request_reason: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param with_siblings: Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.
        :type with_siblings: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_list_serialize(
            external_id=external_id,
            full_response=full_response,
            x_request_id=x_request_id,
            x_request_reason=x_request_reason,
            with_qualities=with_qualities,
            with_siblings=with_siblings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_list_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="Comma-separated list of External ID")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        x_request_reason: Annotated[Optional[StrictStr], Field(description="Supporting information why the request was called")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        with_siblings: Annotated[Optional[StrictBool], Field(description="Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApplicantResponse]]:
        """Get applicants by External ID

        Get applicants by External ID

        :param external_id: Comma-separated list of External ID (required)
        :type external_id: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param x_request_reason: Supporting information why the request was called
        :type x_request_reason: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param with_siblings: Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.
        :type with_siblings: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_list_serialize(
            external_id=external_id,
            full_response=full_response,
            x_request_id=x_request_id,
            x_request_reason=x_request_reason,
            with_qualities=with_qualities,
            with_siblings=with_siblings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_list_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="Comma-separated list of External ID")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        x_request_reason: Annotated[Optional[StrictStr], Field(description="Supporting information why the request was called")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        with_siblings: Annotated[Optional[StrictBool], Field(description="Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicants by External ID

        Get applicants by External ID

        :param external_id: Comma-separated list of External ID (required)
        :type external_id: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param x_request_reason: Supporting information why the request was called
        :type x_request_reason: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param with_siblings: Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.
        :type with_siblings: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_list_serialize(
            external_id=external_id,
            full_response=full_response,
            x_request_id=x_request_id,
            x_request_reason=x_request_reason,
            with_qualities=with_qualities,
            with_siblings=with_siblings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_list_serialize(
        self,
        external_id,
        full_response,
        x_request_id,
        x_request_reason,
        with_qualities,
        with_siblings,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if external_id is not None:
            
            _query_params.append(('externalId', external_id))
            
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        if with_qualities is not None:
            
            _query_params.append(('withQualities', with_qualities))
            
        if with_siblings is not None:
            
            _query_params.append(('withSiblings', with_siblings))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        if x_request_reason is not None:
            _header_params['X-Request-Reason'] = x_request_reason
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_list_by_custom_field(
        self,
        custom_field_name: Annotated[StrictStr, Field(description="Name of the custom field that is used to filter returned applicants.")],
        custom_field_value: Annotated[StrictStr, Field(description="Value of the custom field that is used to filter returned applicants.")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        with_siblings: Annotated[Optional[StrictBool], Field(description="Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicantResponse]:
        """Get applicants by custom field

        Get applicants by custom field

        :param custom_field_name: Name of the custom field that is used to filter returned applicants. (required)
        :type custom_field_name: str
        :param custom_field_value: Value of the custom field that is used to filter returned applicants. (required)
        :type custom_field_value: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param with_siblings: Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.
        :type with_siblings: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_list_by_custom_field_serialize(
            custom_field_name=custom_field_name,
            custom_field_value=custom_field_value,
            full_response=full_response,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            with_siblings=with_siblings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_list_by_custom_field_with_http_info(
        self,
        custom_field_name: Annotated[StrictStr, Field(description="Name of the custom field that is used to filter returned applicants.")],
        custom_field_value: Annotated[StrictStr, Field(description="Value of the custom field that is used to filter returned applicants.")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        with_siblings: Annotated[Optional[StrictBool], Field(description="Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApplicantResponse]]:
        """Get applicants by custom field

        Get applicants by custom field

        :param custom_field_name: Name of the custom field that is used to filter returned applicants. (required)
        :type custom_field_name: str
        :param custom_field_value: Value of the custom field that is used to filter returned applicants. (required)
        :type custom_field_value: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param with_siblings: Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.
        :type with_siblings: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_list_by_custom_field_serialize(
            custom_field_name=custom_field_name,
            custom_field_value=custom_field_value,
            full_response=full_response,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            with_siblings=with_siblings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_list_by_custom_field_without_preload_content(
        self,
        custom_field_name: Annotated[StrictStr, Field(description="Name of the custom field that is used to filter returned applicants.")],
        custom_field_value: Annotated[StrictStr, Field(description="Value of the custom field that is used to filter returned applicants.")],
        full_response: Annotated[Optional[StrictBool], Field(description="Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        with_siblings: Annotated[Optional[StrictBool], Field(description="Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicants by custom field

        Get applicants by custom field

        :param custom_field_name: Name of the custom field that is used to filter returned applicants. (required)
        :type custom_field_name: str
        :param custom_field_value: Value of the custom field that is used to filter returned applicants. (required)
        :type custom_field_value: str
        :param full_response: Defines how detailed data will be returned, when set to false only id, createdAt, updatedAt, enrolledAt, enrolledBy, exportedAt, exportedBy, gallery and customDetails are returned. When true a full applicant object is returned.
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param with_siblings: Defines whether the response should contain all applicants of a biometric individual. For example, if the biometric individual of applicant A1 contains two applicants, A1 and A2, the result will contain both of these applicants. The default value is false.
        :type with_siblings: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_list_by_custom_field_serialize(
            custom_field_name=custom_field_name,
            custom_field_value=custom_field_value,
            full_response=full_response,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            with_siblings=with_siblings,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicantResponse]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_list_by_custom_field_serialize(
        self,
        custom_field_name,
        custom_field_value,
        full_response,
        x_request_id,
        with_qualities,
        with_siblings,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if custom_field_name is not None:
            
            _query_params.append(('customFieldName', custom_field_name))
            
        if custom_field_value is not None:
            
            _query_params.append(('customFieldValue', custom_field_value))
            
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        if with_qualities is not None:
            
            _query_params.append(('withQualities', with_qualities))
            
        if with_siblings is not None:
            
            _query_params.append(('withSiblings', with_siblings))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/by-custom-field',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_signature(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantSignatureModality:
        """Get applicant signature by External ID and signature index

        Get applicant signature by External ID and signature index

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantSignatureModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_signature_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantSignatureModality]:
        """Get applicant signature by External ID and signature index

        Get applicant signature by External ID and signature index

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantSignatureModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_signature_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant signature by External ID and signature index

        Get applicant signature by External ID and signature index

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantSignatureModality",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_signature_serialize(
        self,
        external_id,
        signature_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if signature_index is not None:
            _path_params['signatureIndex'] = signature_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/signatures/{signatureIndex}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_signature_image(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Get signature image of applicant (identified by External ID). The signature is identified by signature index.

        Get signature image of applicant (identified by External ID). The signature is identified by signature index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_image_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_signature_image_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Get signature image of applicant (identified by External ID). The signature is identified by signature index.

        Get signature image of applicant (identified by External ID). The signature is identified by signature index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_image_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_signature_image_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get signature image of applicant (identified by External ID). The signature is identified by signature index.

        Get signature image of applicant (identified by External ID). The signature is identified by signature index.

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_image_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_signature_image_serialize(
        self,
        external_id,
        signature_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if signature_index is not None:
            _path_params['signatureIndex'] = signature_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/octet-stream'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/signatures/{signatureIndex}/image',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_signature_qualities(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SignatureQualitiesGetResponse:
        """Get applicant signature qualities by External ID and signature index

        Get applicant signature qualities by External ID and signature index

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_qualities_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignatureQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_signature_qualities_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SignatureQualitiesGetResponse]:
        """Get applicant signature qualities by External ID and signature index

        Get applicant signature qualities by External ID and signature index

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_qualities_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignatureQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_signature_qualities_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        signature_index: Annotated[StrictInt, Field(description="Object index, starts from 1")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant signature qualities by External ID and signature index

        Get applicant signature qualities by External ID and signature index

        :param external_id: External ID. (required)
        :type external_id: str
        :param signature_index: Object index, starts from 1 (required)
        :type signature_index: int
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signature_qualities_serialize(
            external_id=external_id,
            signature_index=signature_index,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SignatureQualitiesGetResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_signature_qualities_serialize(
        self,
        external_id,
        signature_index,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if signature_index is not None:
            _path_params['signatureIndex'] = signature_index
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/signatures/{signatureIndex}/qualities',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_signatures(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FullApplicantSignatureModality]:
        """Get applicant signatures by External ID

        Get applicant signatures by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signatures_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FullApplicantSignatureModality]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_signatures_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FullApplicantSignatureModality]]:
        """Get applicant signatures by External ID

        Get applicant signatures by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signatures_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FullApplicantSignatureModality]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_signatures_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        with_qualities: Annotated[Optional[StrictBool], Field(description="Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant signatures by External ID

        Get applicant signatures by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param with_qualities: Defines how detailed modality data will be returned. When set to true modality images and templates will have their qualities included.
        :type with_qualities: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_signatures_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            with_qualities=with_qualities,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FullApplicantSignatureModality]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_signatures_serialize(
        self,
        external_id,
        x_request_id,
        with_qualities,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if with_qualities is not None:
            
            _query_params.append(('withQualities', with_qualities))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/signatures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_smt_characteristics(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FullApplicantSmtCharacteristics:
        """Get applicant SMT characteristics by External ID

        Get applicant SMT characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_smt_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantSmtCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_smt_characteristics_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FullApplicantSmtCharacteristics]:
        """Get applicant SMT characteristics by External ID

        Get applicant SMT characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_smt_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantSmtCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_smt_characteristics_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get applicant SMT characteristics by External ID

        Get applicant SMT characteristics by External ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_smt_characteristics_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FullApplicantSmtCharacteristics",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_smt_characteristics_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/abis/v6/applicants/{externalId}/smt-characteristics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def identify(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        identify_applicant_request: IdentifyApplicantRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[IdentificationCandidate]:
        """Performs one-to-many identification of probe applicant identified by External ID.

        Performs one-to-many identification of probe applicant identified by External ID. Returns list of candidate applicants.

        :param external_id: External ID. (required)
        :type external_id: str
        :param identify_applicant_request: (required)
        :type identify_applicant_request: IdentifyApplicantRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param persistent: Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_serialize(
            external_id=external_id,
            identify_applicant_request=identify_applicant_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def identify_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        identify_applicant_request: IdentifyApplicantRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[IdentificationCandidate]]:
        """Performs one-to-many identification of probe applicant identified by External ID.

        Performs one-to-many identification of probe applicant identified by External ID. Returns list of candidate applicants.

        :param external_id: External ID. (required)
        :type external_id: str
        :param identify_applicant_request: (required)
        :type identify_applicant_request: IdentifyApplicantRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param persistent: Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_serialize(
            external_id=external_id,
            identify_applicant_request=identify_applicant_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def identify_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        identify_applicant_request: IdentifyApplicantRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-many identification of probe applicant identified by External ID.

        Performs one-to-many identification of probe applicant identified by External ID. Returns list of candidate applicants.

        :param external_id: External ID. (required)
        :type external_id: str
        :param identify_applicant_request: (required)
        :type identify_applicant_request: IdentifyApplicantRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param persistent: Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_serialize(
            external_id=external_id,
            identify_applicant_request=identify_applicant_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[IdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _identify_serialize(
        self,
        external_id,
        identify_applicant_request,
        full_response,
        persistent,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        if persistent is not None:
            
            _query_params.append(('persistent', persistent))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if identify_applicant_request is not None:
            _body_params = identify_applicant_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/identify',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def identify_dna(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        identify_probe_dna_request: IdentifyProbeDnaRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DnaIdentificationCandidate]:
        """Performs one-to-many DNA identification of probe applicant identified by External ID.

        Performs one-to-many DNA identification of probe applicant identified by External ID. Returns list of candidate applicants.

        :param external_id: External ID. (required)
        :type external_id: str
        :param identify_probe_dna_request: (required)
        :type identify_probe_dna_request: IdentifyProbeDnaRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_dna_serialize(
            external_id=external_id,
            identify_probe_dna_request=identify_probe_dna_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DnaIdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def identify_dna_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        identify_probe_dna_request: IdentifyProbeDnaRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DnaIdentificationCandidate]]:
        """Performs one-to-many DNA identification of probe applicant identified by External ID.

        Performs one-to-many DNA identification of probe applicant identified by External ID. Returns list of candidate applicants.

        :param external_id: External ID. (required)
        :type external_id: str
        :param identify_probe_dna_request: (required)
        :type identify_probe_dna_request: IdentifyProbeDnaRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_dna_serialize(
            external_id=external_id,
            identify_probe_dna_request=identify_probe_dna_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DnaIdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def identify_dna_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        identify_probe_dna_request: IdentifyProbeDnaRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-many DNA identification of probe applicant identified by External ID.

        Performs one-to-many DNA identification of probe applicant identified by External ID. Returns list of candidate applicants.

        :param external_id: External ID. (required)
        :type external_id: str
        :param identify_probe_dna_request: (required)
        :type identify_probe_dna_request: IdentifyProbeDnaRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_dna_serialize(
            external_id=external_id,
            identify_probe_dna_request=identify_probe_dna_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DnaIdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _identify_dna_serialize(
        self,
        external_id,
        identify_probe_dna_request,
        full_response,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if identify_probe_dna_request is not None:
            _body_params = identify_probe_dna_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/identify/dna',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def identify_latents(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_identify_applicant_request: LatentIdentifyApplicantRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LatentIdentificationCandidate]:
        """Performs one-to-many identification of probe applicant identified by External ID in latent galleries.

        Performs one-to-many identification of probe applicant identified by External ID in latent galleries. Returns list of candidate applicants from latent galleries.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_identify_applicant_request: (required)
        :type latent_identify_applicant_request: LatentIdentifyApplicantRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param persistent: Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_latents_serialize(
            external_id=external_id,
            latent_identify_applicant_request=latent_identify_applicant_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentIdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def identify_latents_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_identify_applicant_request: LatentIdentifyApplicantRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[LatentIdentificationCandidate]]:
        """Performs one-to-many identification of probe applicant identified by External ID in latent galleries.

        Performs one-to-many identification of probe applicant identified by External ID in latent galleries. Returns list of candidate applicants from latent galleries.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_identify_applicant_request: (required)
        :type latent_identify_applicant_request: LatentIdentifyApplicantRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param persistent: Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_latents_serialize(
            external_id=external_id,
            latent_identify_applicant_request=latent_identify_applicant_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentIdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def identify_latents_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_identify_applicant_request: LatentIdentifyApplicantRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="defines how detailed data will be returned")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-many identification of probe applicant identified by External ID in latent galleries.

        Performs one-to-many identification of probe applicant identified by External ID in latent galleries. Returns list of candidate applicants from latent galleries.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_identify_applicant_request: (required)
        :type latent_identify_applicant_request: LatentIdentifyApplicantRequest
        :param full_response: defines how detailed data will be returned
        :type full_response: bool
        :param persistent: Defines whether persistence of identification result is enabled.This parameter is available only for contextual identification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the identification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._identify_latents_serialize(
            external_id=external_id,
            latent_identify_applicant_request=latent_identify_applicant_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentIdentificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _identify_latents_serialize(
        self,
        external_id,
        latent_identify_applicant_request,
        full_response,
        persistent,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        if persistent is not None:
            
            _query_params.append(('persistent', persistent))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if latent_identify_applicant_request is not None:
            _body_params = latent_identify_applicant_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/identify/latent',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def masterize(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantResponse:
        """Masterize applicant

        Masterize (i.e change applicant status to master) enrolled applicant identified by External Id.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._masterize_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def masterize_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantResponse]:
        """Masterize applicant

        Masterize (i.e change applicant status to master) enrolled applicant identified by External Id.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._masterize_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def masterize_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Masterize applicant

        Masterize (i.e change applicant status to master) enrolled applicant identified by External Id.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._masterize_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _masterize_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/masterize',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def merge_applicants(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        reference_external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> int:
        """(Deprecated) Merge applicant based on probe and reference external ID

        Note this API is experimental since OpenAPI version 6.0.0 because ABIS does not support resolving Merge hitlists currentlyCreate hitlist programmatically by merging two applicants based on probe and reference external ids. Returns hitlist ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param reference_external_id: External ID. (required)
        :type reference_external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PUT /abis/v6/applicants/{externalId}/merge/{referenceExternalId} is deprecated.", DeprecationWarning)

        _param = self._merge_applicants_serialize(
            external_id=external_id,
            reference_external_id=reference_external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def merge_applicants_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        reference_external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[int]:
        """(Deprecated) Merge applicant based on probe and reference external ID

        Note this API is experimental since OpenAPI version 6.0.0 because ABIS does not support resolving Merge hitlists currentlyCreate hitlist programmatically by merging two applicants based on probe and reference external ids. Returns hitlist ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param reference_external_id: External ID. (required)
        :type reference_external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PUT /abis/v6/applicants/{externalId}/merge/{referenceExternalId} is deprecated.", DeprecationWarning)

        _param = self._merge_applicants_serialize(
            external_id=external_id,
            reference_external_id=reference_external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def merge_applicants_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        reference_external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) Merge applicant based on probe and reference external ID

        Note this API is experimental since OpenAPI version 6.0.0 because ABIS does not support resolving Merge hitlists currentlyCreate hitlist programmatically by merging two applicants based on probe and reference external ids. Returns hitlist ID

        :param external_id: External ID. (required)
        :type external_id: str
        :param reference_external_id: External ID. (required)
        :type reference_external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("PUT /abis/v6/applicants/{externalId}/merge/{referenceExternalId} is deprecated.", DeprecationWarning)

        _param = self._merge_applicants_serialize(
            external_id=external_id,
            reference_external_id=reference_external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _merge_applicants_serialize(
        self,
        external_id,
        reference_external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if reference_external_id is not None:
            _path_params['referenceExternalId'] = reference_external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/abis/v6/applicants/{externalId}/merge/{referenceExternalId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def move_to_gallery(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID")],
        gallery_name: Annotated[StrictStr, Field(description="Gallery name")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantIdentifierResponse:
        """Move applicant identified by external ID to gallery identified by gallery name

        Move applicant identified by external ID to gallery identified by gallery name. In matcher cluster, templates of the specified applicant will be deleted for old gallery and inserted for new gallery.

        :param external_id: External ID (required)
        :type external_id: str
        :param gallery_name: Gallery name (required)
        :type gallery_name: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._move_to_gallery_serialize(
            external_id=external_id,
            gallery_name=gallery_name,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def move_to_gallery_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID")],
        gallery_name: Annotated[StrictStr, Field(description="Gallery name")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantIdentifierResponse]:
        """Move applicant identified by external ID to gallery identified by gallery name

        Move applicant identified by external ID to gallery identified by gallery name. In matcher cluster, templates of the specified applicant will be deleted for old gallery and inserted for new gallery.

        :param external_id: External ID (required)
        :type external_id: str
        :param gallery_name: Gallery name (required)
        :type gallery_name: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._move_to_gallery_serialize(
            external_id=external_id,
            gallery_name=gallery_name,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def move_to_gallery_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID")],
        gallery_name: Annotated[StrictStr, Field(description="Gallery name")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Move applicant identified by external ID to gallery identified by gallery name

        Move applicant identified by external ID to gallery identified by gallery name. In matcher cluster, templates of the specified applicant will be deleted for old gallery and inserted for new gallery.

        :param external_id: External ID (required)
        :type external_id: str
        :param gallery_name: Gallery name (required)
        :type gallery_name: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._move_to_gallery_serialize(
            external_id=external_id,
            gallery_name=gallery_name,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _move_to_gallery_serialize(
        self,
        external_id,
        gallery_name,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        if gallery_name is not None:
            _path_params['galleryName'] = gallery_name
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/abis/v6/applicants/{externalId}/move-to-gallery/{galleryName}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reinstate(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantResponse:
        """Reinstate applicant.

        Reinstate deleted or rejected applicant single in its biometric individual (i.e. without any siblings). Applicant status is changed to enrolled.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reinstate_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reinstate_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantResponse]:
        """Reinstate applicant.

        Reinstate deleted or rejected applicant single in its biometric individual (i.e. without any siblings). Applicant status is changed to enrolled.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reinstate_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reinstate_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Reinstate applicant.

        Reinstate deleted or rejected applicant single in its biometric individual (i.e. without any siblings). Applicant status is changed to enrolled.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reinstate_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reinstate_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/reinstate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reject(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DeleteApplicantResponse]:
        """Soft-deletes applicant (identified by External ID) and changes its status to Rejected

        Soft-deletes applicant (identified by External ID) and changes its status to Rejected. Rejected applicant still exists in ABIS database but not in Matching cluster. Rejected applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reject_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reject_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DeleteApplicantResponse]]:
        """Soft-deletes applicant (identified by External ID) and changes its status to Rejected

        Soft-deletes applicant (identified by External ID) and changes its status to Rejected. Rejected applicant still exists in ABIS database but not in Matching cluster. Rejected applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reject_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reject_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Soft-deletes applicant (identified by External ID) and changes its status to Rejected

        Soft-deletes applicant (identified by External ID) and changes its status to Rejected. Rejected applicant still exists in ABIS database but not in Matching cluster. Rejected applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reject_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DeleteApplicantResponse]",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reject_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/reject',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeleteApplicantResponse:
        """Removes (hard-deletes) applicant (identified by External ID).

        Removes (hard-deletes) applicant (identified by External ID). Removed applicant and its content does not exist in ABIS database anymore. Removed applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeleteApplicantResponse]:
        """Removes (hard-deletes) applicant (identified by External ID).

        Removes (hard-deletes) applicant (identified by External ID). Removed applicant and its content does not exist in ABIS database anymore. Removed applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Removes (hard-deletes) applicant (identified by External ID).

        Removes (hard-deletes) applicant (identified by External ID). Removed applicant and its content does not exist in ABIS database anymore. Removed applicant can't be found by identify operation

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/abis/v6/applicants/{externalId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def split(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantResponse:
        """Splits applicant from its biometric individual

        Splits non-primary archived, rejected, deleted or suspect applicant from its biometric individual. Applicant is moved under newly created biometric individual and its status is set to enrolled.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._split_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def split_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantResponse]:
        """Splits applicant from its biometric individual

        Splits non-primary archived, rejected, deleted or suspect applicant from its biometric individual. Applicant is moved under newly created biometric individual and its status is set to enrolled.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._split_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def split_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Splits applicant from its biometric individual

        Splits non-primary archived, rejected, deleted or suspect applicant from its biometric individual. Applicant is moved under newly created biometric individual and its status is set to enrolled.

        :param external_id: External ID. (required)
        :type external_id: str
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._split_serialize(
            external_id=external_id,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantResponse",
            '400': "ErrorResponseStandard",
            '403': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _split_serialize(
        self,
        external_id,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/split',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantIdentifierResponse:
        """Update data of applicant identified using External ID

        Update data of applicant (identified by External ID). The existing applicant data will be replaced by new data in request.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantIdentifierResponse]:
        """Update data of applicant identified using External ID

        Update data of applicant (identified by External ID). The existing applicant data will be replaced by new data in request.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        full_applicant_request: FullApplicantRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update data of applicant identified using External ID

        Update data of applicant (identified by External ID). The existing applicant data will be replaced by new data in request.

        :param external_id: External ID. (required)
        :type external_id: str
        :param full_applicant_request: (required)
        :type full_applicant_request: FullApplicantRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_serialize(
            external_id=external_id,
            full_applicant_request=full_applicant_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_serialize(
        self,
        external_id,
        full_applicant_request,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if full_applicant_request is not None:
            _body_params = full_applicant_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/abis/v6/applicants/{externalId}/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_fields(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        update_fields_request: UpdateFieldsRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicantIdentifierResponse:
        """Update fields of applicant identified using External ID

        Update fields of applicant (identified by External ID). The existing applicant fields will be replaced by new fields in request.

        :param external_id: External ID. (required)
        :type external_id: str
        :param update_fields_request: (required)
        :type update_fields_request: UpdateFieldsRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_fields_serialize(
            external_id=external_id,
            update_fields_request=update_fields_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_fields_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        update_fields_request: UpdateFieldsRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicantIdentifierResponse]:
        """Update fields of applicant identified using External ID

        Update fields of applicant (identified by External ID). The existing applicant fields will be replaced by new fields in request.

        :param external_id: External ID. (required)
        :type external_id: str
        :param update_fields_request: (required)
        :type update_fields_request: UpdateFieldsRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_fields_serialize(
            external_id=external_id,
            update_fields_request=update_fields_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_fields_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        update_fields_request: UpdateFieldsRequest,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update fields of applicant identified using External ID

        Update fields of applicant (identified by External ID). The existing applicant fields will be replaced by new fields in request.

        :param external_id: External ID. (required)
        :type external_id: str
        :param update_fields_request: (required)
        :type update_fields_request: UpdateFieldsRequest
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_fields_serialize(
            external_id=external_id,
            update_fields_request=update_fields_request,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicantIdentifierResponse",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_fields_serialize(
        self,
        external_id,
        update_fields_request,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if update_fields_request is not None:
            _body_params = update_fields_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/abis/v6/applicants/{externalId}/fields',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def verify_dna_references(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_dna_applicant_references_request: VerifyDnaApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[DnaVerificationCandidate]:
        """Performs one-to-one or one-to-few DNA verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few DNA verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_dna_applicant_references_request: (required)
        :type verify_dna_applicant_references_request: VerifyDnaApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_dna_references_serialize(
            external_id=external_id,
            verify_dna_applicant_references_request=verify_dna_applicant_references_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DnaVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def verify_dna_references_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_dna_applicant_references_request: VerifyDnaApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[DnaVerificationCandidate]]:
        """Performs one-to-one or one-to-few DNA verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few DNA verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_dna_applicant_references_request: (required)
        :type verify_dna_applicant_references_request: VerifyDnaApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_dna_references_serialize(
            external_id=external_id,
            verify_dna_applicant_references_request=verify_dna_applicant_references_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DnaVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def verify_dna_references_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_dna_applicant_references_request: VerifyDnaApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-one or one-to-few DNA verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few DNA verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_dna_applicant_references_request: (required)
        :type verify_dna_applicant_references_request: VerifyDnaApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_dna_references_serialize(
            external_id=external_id,
            verify_dna_applicant_references_request=verify_dna_applicant_references_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[DnaVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _verify_dna_references_serialize(
        self,
        external_id,
        verify_dna_applicant_references_request,
        full_response,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if verify_dna_applicant_references_request is not None:
            _body_params = verify_dna_applicant_references_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/verify/dna/references',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def verify_images(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_images_request: VerifyApplicantImagesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[VerificationCandidate]:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against images.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against images.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_images_request: (required)
        :type verify_applicant_images_request: VerifyApplicantImagesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_images_serialize(
            external_id=external_id,
            verify_applicant_images_request=verify_applicant_images_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def verify_images_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_images_request: VerifyApplicantImagesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[VerificationCandidate]]:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against images.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against images.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_images_request: (required)
        :type verify_applicant_images_request: VerifyApplicantImagesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_images_serialize(
            external_id=external_id,
            verify_applicant_images_request=verify_applicant_images_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def verify_images_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_images_request: VerifyApplicantImagesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against images.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against images.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_images_request: (required)
        :type verify_applicant_images_request: VerifyApplicantImagesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_images_serialize(
            external_id=external_id,
            verify_applicant_images_request=verify_applicant_images_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _verify_images_serialize(
        self,
        external_id,
        verify_applicant_images_request,
        full_response,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if verify_applicant_images_request is not None:
            _body_params = verify_applicant_images_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/verify/images',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def verify_latent_images(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_verify_applicant_images_request: LatentVerifyApplicantImagesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LatentVerificationCandidate]:
        """Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against images.

        Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against images.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_verify_applicant_images_request: (required)
        :type latent_verify_applicant_images_request: LatentVerifyApplicantImagesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_latent_images_serialize(
            external_id=external_id,
            latent_verify_applicant_images_request=latent_verify_applicant_images_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def verify_latent_images_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_verify_applicant_images_request: LatentVerifyApplicantImagesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[LatentVerificationCandidate]]:
        """Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against images.

        Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against images.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_verify_applicant_images_request: (required)
        :type latent_verify_applicant_images_request: LatentVerifyApplicantImagesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_latent_images_serialize(
            external_id=external_id,
            latent_verify_applicant_images_request=latent_verify_applicant_images_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def verify_latent_images_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_verify_applicant_images_request: LatentVerifyApplicantImagesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against images.

        Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against images.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_verify_applicant_images_request: (required)
        :type latent_verify_applicant_images_request: LatentVerifyApplicantImagesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_latent_images_serialize(
            external_id=external_id,
            latent_verify_applicant_images_request=latent_verify_applicant_images_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _verify_latent_images_serialize(
        self,
        external_id,
        latent_verify_applicant_images_request,
        full_response,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if latent_verify_applicant_images_request is not None:
            _body_params = latent_verify_applicant_images_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/verify/latent/images',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def verify_latent_references(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_verify_applicant_references_request: LatentVerifyApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LatentVerificationCandidate]:
        """Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_verify_applicant_references_request: (required)
        :type latent_verify_applicant_references_request: LatentVerifyApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param persistent: Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_latent_references_serialize(
            external_id=external_id,
            latent_verify_applicant_references_request=latent_verify_applicant_references_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def verify_latent_references_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_verify_applicant_references_request: LatentVerifyApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[LatentVerificationCandidate]]:
        """Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_verify_applicant_references_request: (required)
        :type latent_verify_applicant_references_request: LatentVerifyApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param persistent: Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_latent_references_serialize(
            external_id=external_id,
            latent_verify_applicant_references_request=latent_verify_applicant_references_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def verify_latent_references_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        latent_verify_applicant_references_request: LatentVerifyApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few latent verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param latent_verify_applicant_references_request: (required)
        :type latent_verify_applicant_references_request: LatentVerifyApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param persistent: Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_latent_references_serialize(
            external_id=external_id,
            latent_verify_applicant_references_request=latent_verify_applicant_references_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LatentVerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _verify_latent_references_serialize(
        self,
        external_id,
        latent_verify_applicant_references_request,
        full_response,
        persistent,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        if persistent is not None:
            
            _query_params.append(('persistent', persistent))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if latent_verify_applicant_references_request is not None:
            _body_params = latent_verify_applicant_references_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/verify/latent/references',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def verify_references(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_references_request: VerifyApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[VerificationCandidate]:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_references_request: (required)
        :type verify_applicant_references_request: VerifyApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param persistent: Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_references_serialize(
            external_id=external_id,
            verify_applicant_references_request=verify_applicant_references_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def verify_references_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_references_request: VerifyApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[VerificationCandidate]]:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_references_request: (required)
        :type verify_applicant_references_request: VerifyApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param persistent: Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_references_serialize(
            external_id=external_id,
            verify_applicant_references_request=verify_applicant_references_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def verify_references_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_references_request: VerifyApplicantReferencesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        persistent: Annotated[Optional[StrictBool], Field(description="Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against applicants in database. Applicants in database are identified by External ID.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_references_request: (required)
        :type verify_applicant_references_request: VerifyApplicantReferencesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param persistent: Defines whether persistence of verification result is enabled.This parameter is available only for contextual verification (e.g. probe / reference templates are referenced by External ID).When set to true, result of the verification will be stored in the database.
        :type persistent: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_references_serialize(
            external_id=external_id,
            verify_applicant_references_request=verify_applicant_references_request,
            full_response=full_response,
            persistent=persistent,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '429': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _verify_references_serialize(
        self,
        external_id,
        verify_applicant_references_request,
        full_response,
        persistent,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        if persistent is not None:
            
            _query_params.append(('persistent', persistent))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if verify_applicant_references_request is not None:
            _body_params = verify_applicant_references_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/verify/references',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def verify_templates(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_templates_request: VerifyApplicantTemplatesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[VerificationCandidate]:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against single modality templates.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against single modality templates.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_templates_request: (required)
        :type verify_applicant_templates_request: VerifyApplicantTemplatesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_templates_serialize(
            external_id=external_id,
            verify_applicant_templates_request=verify_applicant_templates_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def verify_templates_with_http_info(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_templates_request: VerifyApplicantTemplatesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[VerificationCandidate]]:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against single modality templates.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against single modality templates.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_templates_request: (required)
        :type verify_applicant_templates_request: VerifyApplicantTemplatesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_templates_serialize(
            external_id=external_id,
            verify_applicant_templates_request=verify_applicant_templates_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def verify_templates_without_preload_content(
        self,
        external_id: Annotated[StrictStr, Field(description="External ID.")],
        verify_applicant_templates_request: VerifyApplicantTemplatesRequest,
        full_response: Annotated[Optional[StrictBool], Field(description="Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="(idempotency) in case of retry returns previous success response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Performs one-to-one or one-to-few verification of applicant (identified by External ID) against single modality templates.

        Performs one-to-one or one-to-few verification of applicant (identified by External ID) against single modality templates.

        :param external_id: External ID. (required)
        :type external_id: str
        :param verify_applicant_templates_request: (required)
        :type verify_applicant_templates_request: VerifyApplicantTemplatesRequest
        :param full_response: Defines whether or not partial scores for all combinations of biometric data will be returned (i.e. also scores for e.g. left index vs right middle finger)
        :type full_response: bool
        :param x_request_id: (idempotency) in case of retry returns previous success response
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._verify_templates_serialize(
            external_id=external_id,
            verify_applicant_templates_request=verify_applicant_templates_request,
            full_response=full_response,
            x_request_id=x_request_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[VerificationCandidate]",
            '400': "ErrorResponseStandard",
            '500': "ErrorResponseStandard",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _verify_templates_serialize(
        self,
        external_id,
        verify_applicant_templates_request,
        full_response,
        x_request_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if external_id is not None:
            _path_params['externalId'] = external_id
        # process the query parameters
        if full_response is not None:
            
            _query_params.append(('fullResponse', full_response))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if verify_applicant_templates_request is not None:
            _body_params = verify_applicant_templates_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                '*/*'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'basicAuth', 
            'oauth2', 
            'oauth2'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/abis/v6/applicants/{externalId}/verify/templates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


